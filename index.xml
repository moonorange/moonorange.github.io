<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kei's Blog</title><link>https://moonorange.github.io/</link><description>Recent content on Kei's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 23 Apr 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://moonorange.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Learn gRPC, GraphQL and Kubernetes by building Microservices: Part 3 - Kubernetes</title><link>https://moonorange.github.io/posts/projects_to_learn/go_microservices/part3/</link><pubDate>Tue, 23 Apr 2024 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/projects_to_learn/go_microservices/part3/</guid><description>Intro This is the third and last post in a series about learning gRPC, GraphQL and Kubernetes by building Microservices in Go.
Here is a list of posts in the series:
Part 1 - gRPC Microservices Part 2 - GraphQL BFF Part 3 - Deploy services by Kubernetes Full code is in here
We have implemented gRPC servers and BFF in parts 1 and 2.
In part 3, we will deploy those services on Minikube using Kubernetes.</description></item><item><title>Learn gRPC, GraphQL and Kubernetes by building Microservices in Go: Part 2 - GraphQL BFF</title><link>https://moonorange.github.io/posts/projects_to_learn/go_microservices/part2/</link><pubDate>Mon, 22 Apr 2024 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/projects_to_learn/go_microservices/part2/</guid><description>Intro This is the second post in a series about learning gRPC, GraphQL and Kubernetes by building Microservices in Go. Here is a list of posts in the series:
Part 1 - gRPC Microservices Part 2 - GraphQL BFF Part 3 - Deploy services by Kubernetes Full code is in here
We have implemented gRPC servers in part 1.
In part 2, we will develop a BFF server that reads from and writes to these gRPC servers and communicates with clients using GraphQL.</description></item><item><title>Learn gRPC, GraphQL and Kubernetes by building Microservices: Part 1 - Building gRPC Microservices</title><link>https://moonorange.github.io/posts/projects_to_learn/go_microservices/part1/</link><pubDate>Sun, 21 Apr 2024 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/projects_to_learn/go_microservices/part1/</guid><description>Intro This is the first post in a series about learning gRPC, GraphQL and Kubernetes by building Microservices in Go.
In this series of posts, we will embark on a journey to implement a Backend For Frontend (BFF) and microservices architecture, leveraging gRPC and GraphQL. Additionally, we&amp;rsquo;ll demonstrate how to deploy these services locally using Kubernetes.
This project serves as an educational endeavor to understand the microservices communication and the benefits of using gRPC, GraphQL, and Kubernetes.</description></item><item><title>Implementation of Job Queue model using goroutine and channel</title><link>https://moonorange.github.io/posts/programming_language/job_queues_go/</link><pubDate>Thu, 11 Apr 2024 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/programming_language/job_queues_go/</guid><description>Introduction In concurrent programming, managing tasks efficiently is crucial. One common pattern is the job queue model, where multiple tasks (jobs) are submitted to a queue and processed asynchronously by worker routines. In this blog post, we&amp;rsquo;ll explore how to implement a job queue model in Go using goroutines and channels.
Understanding the Job Queue Model At its core, the job queue model consists of two main components:
Job Queue: The job queue is a data structure that holds tasks awaiting execution.</description></item><item><title>Go Concurrency Model</title><link>https://moonorange.github.io/posts/programming_language/go_concurrency_model/</link><pubDate>Sun, 07 Apr 2024 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/programming_language/go_concurrency_model/</guid><description>Intro This article aims to summarize the key concepts and principles of Go&amp;rsquo;s concurrency model that I&amp;rsquo;ve learned.
To test your understanding and reinforce your knowledge, a quiz is available at the end of the article.
Goroutines A goroutine is a lightweight independently executing function with its own call stack.
While not equivalent to a thread, conceptually, it can be thought of as a very cheap thread.
Here&amp;rsquo;s how you can use goroutines:</description></item><item><title>Implementation of Merge Sort in Python</title><link>https://moonorange.github.io/posts/dsa/sort/merge_sort/</link><pubDate>Thu, 05 Oct 2023 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/dsa/sort/merge_sort/</guid><description>Merge Sort In sorting n objects, merge sort has an average and worst-case performance of O(n log n).
Merge sort is a stable sort in the most implementations. The most common implementation does not sort in place, meaning it requires extra space.
Implementation in Python from typing import List # Python merge sort implementation # Time complexity: O(NlogN), space complexity: O(N) def merge_sort(nums: List[int]): # Base case if len(nums) &amp;lt;= 1: return nums mid = len(nums) // 2 left, right = merge_sort(nums[:mid]), merge_sort(nums[mid:]) return merge(left, right) def merge(left: List[int], right: List[int]): i, j = 0, 0 res = [] # Compare the elements in the left and right list and append the smaller one to the result list while i &amp;lt; len(left) and j &amp;lt; len(right): if left[i] &amp;lt;= right[j]: res.</description></item><item><title>Implementation of Quick Sort in Python</title><link>https://moonorange.github.io/posts/dsa/sort/quick_sort/</link><pubDate>Thu, 05 Oct 2023 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/dsa/sort/quick_sort/</guid><description>Quick Sort In sorting n objects, quick sort has an average performance of O(n log n) and a worst performance of O(n^2).
Most implementations of quick sort are not stable, but sort in place, meaning it does not require extra space.
Implementation in Python # O(NLogN), space complexity O(n) in this case def quick_sort(nums): if len(nums) &amp;lt;= 1: return nums pivot = nums[len(nums) // 2] left = [n for n in nums if n &amp;lt; pivot] mid = [n for n in nums if n == pivot] right = [n for n in nums if n &amp;gt; pivot] return quick_sort(left) + mid + quick_sort(right) # Test cases if __name__ == &amp;#34;__main__&amp;#34;: # Test case 1: Sorting an empty list arr1 = [] result1 = quick_sort(arr1) assert result1 == [], &amp;#34;Test case 1 failed&amp;#34; # Test case 2: Sorting a list with one element arr2 = [5] result2 = quick_sort(arr2) assert result2 == [5], &amp;#34;Test case 2 failed&amp;#34; # Test case 3: Sorting a list with multiple elements arr3 = [3, 6, 1, 8, 2, 4, 5, 7] result3 = quick_sort(arr3) assert result3 == [1, 2, 3, 4, 5, 6, 7, 8], &amp;#34;Test case 3 failed&amp;#34; # Test case 4: Sorting a list with duplicate elements arr4 = [3, 6, 1, 8, 2, 4, 5, 7, 1, 2] result4 = quick_sort(arr4) assert result4 == [1, 1, 2, 2, 3, 4, 5, 6, 7, 8], &amp;#34;Test case 4 failed&amp;#34; # Test case 5: Sorting a list with duplicate pivot elements arr5 = [3, 6, 1, 5, 4, 4, 5, 7, 1, 2] result5= quick_sort(arr5) assert result5 == [1, 1, 2, 3, 4, 4, 5, 5, 6, 7], &amp;#34;Test case 5 failed {0}&amp;#34;.</description></item><item><title>Write a Large Amount of Data to CSV File with Go (Golang)</title><link>https://moonorange.github.io/posts/programming_language/golang_goroutines/</link><pubDate>Sat, 09 Sep 2023 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/programming_language/golang_goroutines/</guid><description>Introduction Have you ever found yourself in a situation where you needed to prepare a substantial amount of data for testing your code? If so, you&amp;rsquo;re not alone. Working with large datasets is a common requirement in software development, and Go provides some powerful tools to help you accomplish this efficiently.
In this blog post, I&amp;rsquo;ll share my approach to writing a large amount of data into a CSV file using Go, and I&amp;rsquo;ll demonstrate how to leverage Goroutines to make the process more efficient and faster.</description></item><item><title>Union-Find</title><link>https://moonorange.github.io/posts/dsa/union_find/</link><pubDate>Sat, 19 Aug 2023 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/dsa/union_find/</guid><description>Union-Find Union-Find, aka Disjoint Set, is a rooted tree data structure that can efficiently classifies elements into categories.
By utilizing this data structure, it becomes possible to rapidly determine whether two elements belong to the same group, as well as to swiftly merge two groups.
Implementation in Python class UnionFind: def __init__(self, n): # Initialize all parents as -1, which means all nodes are root nodes self.parent = [-1] * n # Rank holds a weight to determine which tree has more weight # The tree with a smaller rank should be placed under the tree with a greater rank to keep the height of the merged tree smaller self.</description></item><item><title>Understanding Web's content Origin and Site</title><link>https://moonorange.github.io/posts/security/cors/</link><pubDate>Mon, 07 Aug 2023 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/security/cors/</guid><description>Introduction This post summarizes what I have learned when I encountered issues related to CORS and HTTP cookies.
Understanding Domains(hostname), Origins, and Sites It&amp;rsquo;s crucial to comprehend these concepts when dealing with CORS-related problems.
Origin An example of a web content&amp;rsquo;s origin is http://example.com:80. An origin is comprised of the domain (hostname), port, and scheme.
In the case above, http is the scheme, example.com is the domain, and 80 is the port.</description></item><item><title>Implementing TOTP in Go</title><link>https://moonorange.github.io/posts/security/2fa/</link><pubDate>Sat, 01 Apr 2023 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/security/2fa/</guid><description>Introduction In this article, I would like to try implementing a code that generates a one-time password, which is often used in many two-factor authentication functions, called Time-based One-time Password (TOTP), using Go.
What is Two-Factor Authentication? Before writing the TOTP generation code, let&amp;rsquo;s briefly review what two-factor authentication is.
There are mainly three types of factors for authentication: knowledge, possession, and biometrics.
Knowledge: Something only the user knows or remembers, such as a login password.</description></item><item><title>High Performance Browser Networking</title><link>https://moonorange.github.io/posts/cs/hpbn/</link><pubDate>Tue, 17 Jan 2023 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/cs/hpbn/</guid><description>WIP
Chapter 2 Building Blocks of TCP TCP is what provides the abstraction of a reliable network running over an unreliable channel.
TCP abstracts important parts of network such as retransmission of lost data, congestion control, data integrity, and in-order delivery
Chapter 3 Building Blocks of UDP Ref. https://hpbn.co/</description></item><item><title>Designing Data-Intensive Applications</title><link>https://moonorange.github.io/posts/software_design/ddia/</link><pubDate>Sat, 26 Nov 2022 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/software_design/ddia/</guid><description>What&amp;rsquo;s this article about These are my notes on a book called Designing Data-Intensive Applications.
SSTables and LSM Trees(P.76) SSTables (Sorted String Tables) are files that contain a set of arbitrary and sorted key-value pairs.
https://www.igvita.com/2012/02/06/sstable-and-log-structured-storage-leveldb/
SSTables and Log-Structured Merge Trees are still used in some database.
As a rule of thumb, LSM Trees are faster for writes but slower for reads than B-Tree indexes.
B-Trees The B-Tree is the most widely used indexing structure.</description></item><item><title>Dijkstra’s Shortest Path Algorithm</title><link>https://moonorange.github.io/posts/dsa/dijkstra/</link><pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/dsa/dijkstra/</guid><description>What is Dijkstra’s Algorithm Dijkstra&amp;rsquo;s Algorithm is the algorithm to find the shortest path between any two vertices in a graph.
Dijkstra&amp;rsquo;s Algorithm will find the shortest path from a given starting vertex to every other vertices in a graph.
Steps Prepare a table to have the shortest distance from a starting vertex and previous vertex.
Initialize two list of visited and unvisited nodes
Let the distance of a start vertex from the start vertex 0.</description></item><item><title>Google Cloud Fundamentals</title><link>https://moonorange.github.io/posts/public_cloud/google_cloud_fundamentals/</link><pubDate>Sat, 17 Sep 2022 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/public_cloud/google_cloud_fundamentals/</guid><description>概要 https://www.coursera.org/learn/gcp-fundamentals-jp/home/week/1 courseraのクラスのメモ レッドチーム演習 セキュリティを高めるため、サービスに攻撃を仕掛けセキュリティの有効性を確かめる演習 U2F(Universal 2nd Factor)</description></item><item><title>GCP Decision Tree</title><link>https://moonorange.github.io/posts/public_cloud/gcp_decision_tree/</link><pubDate>Sat, 03 Sep 2022 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/public_cloud/gcp_decision_tree/</guid><description>Decision Tree Summarize decision trees to decide which gcp services you should use in a certain circumstance.
Compute option GCP offers a multiple compute services.
Here is a list of those services and how customizable/managed they are.
Decision Tree
Services
Firebase When you&amp;rsquo;re a mobile or html developer and want the least amount of server-side code possible, you should choose Firebase.
Firebase provides Database, Storage, Functions/Services, and Hosting with a little code.</description></item><item><title>Intro to Graphs</title><link>https://moonorange.github.io/posts/dsa/graph/</link><pubDate>Sun, 07 Aug 2022 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/dsa/graph/</guid><description>What is a Graph? A graph G is an ordered pair of a set V of vertices and a set of E of edges. G can be defines as follows $$G=\left(V,E\right)$$ ordered pair $$(a, b) \neq \left(b,a\right) \text{where} \ a \neq b$$ Graph terminology There are two type of graph, the one is directed graph and the other is undirected graph. Directed graphs contain ordered pairs of vertices while undirected</description></item><item><title>Random Notes for system design</title><link>https://moonorange.github.io/posts/software_design/system_design/</link><pubDate>Mon, 27 Jun 2022 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/software_design/system_design/</guid><description>NoSQL database NoSQL databases are non tabular databases.
Features
Flexible schema Horizontal scaling Fast queries due to the data model Ease of use for developers Types The main types are document, key-value, wide-column, and graph.
Document databases Document databases store data in documents similar to JSON objects.
Particular elements can be indexed for faster querying.
They have the flexibility to rework their document structures as needed.
Use cases include e-commerce platforms, trading platforms, and mobile app development.</description></item><item><title>BFS and DFS</title><link>https://moonorange.github.io/posts/dsa/bfs_dfs/</link><pubDate>Sun, 19 Jun 2022 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/dsa/bfs_dfs/</guid><description>BFS Template A template in a python-ish pseudo-code for bfs from collections import deque def bfs(root, target): step = 0 # Enqueue root node in queue q = deque([root]) # Set to store visited nodes visited = set(q) while q: size = len(q) # Iterated the nodes which are already in the queue for _ in range(size): # Pop the first node in the queue curr = q.popleft if curr</description></item><item><title>Stack and Queue</title><link>https://moonorange.github.io/posts/dsa/queue_stacks/</link><pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/dsa/queue_stacks/</guid><description>Queue FIFO
package queue import &amp;#34;sync&amp;#34; type node struct { data interface{} next *node } type Queue struct { head *node tail *node count int lock *sync.Mutex } func NewQueue() *Queue { return &amp;amp;Queue{lock: &amp;amp;sync.Mutex{}} } func (q *Queue) Len() int { q.lock.Lock() defer q.lock.Unlock() return q.count } func (q *Queue) Push(data interface{}) { q.lock.Lock() defer q.lock.Unlock() ele := &amp;amp;node{data: data} if q.head == nil { q.head = ele q.tail = ele } else { q.</description></item><item><title>Heap</title><link>https://moonorange.github.io/posts/dsa/heap/</link><pubDate>Wed, 13 Apr 2022 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/dsa/heap/</guid><description>Heap Heap is a special Tree-based data structure in which tree is a complete binary tree. Heaps are basically are binary trees with more properties and specifications and there are mainly two types of heaps.
Rules
A heap must be a complete binary tree. All of the levels of the tree must be completely filled except maybe the last one. The last level has all keys as left as possible Types of heap Min Heap</description></item><item><title>Tries</title><link>https://moonorange.github.io/posts/dsa/tries/</link><pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/dsa/tries/</guid><description>Tries It is commonly used to represent a dictionary for looking up words in a vocabulary
Implementation https://leetcode.com/problems/implement-trie-prefix-tree/
Trie() Initializes the trie object. void insert(String word) Inserts the string word into the trie. boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise. boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix, and false otherwise.</description></item><item><title>Tree</title><link>https://moonorange.github.io/posts/dsa/tree/</link><pubDate>Fri, 08 Apr 2022 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/dsa/tree/</guid><description>Tree Properties Every tree has a special node called the root node. The root node can be used to traverse every node of the tree. It is called root because the tree originated from root only. If a tree has N nodes(vertices), the number of edges is always one less than the number of nodes (i.e., N-1). If it has more than that, it&amp;rsquo;s called a graph not a tree.</description></item><item><title>Infrastructure Setup Guide on AWS with Terraform</title><link>https://moonorange.github.io/posts/public_cloud/terraform_provisioning_en/</link><pubDate>Fri, 17 Dec 2021 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/public_cloud/terraform_provisioning_en/</guid><description>Infrastructure Setup Guide This document outlines the steps for building a deployment environment for a web service on using AWS and Terraform. Infrastructure CI/CD is also achieved through Terraform Cloud and GitHub Actions. Basic explanations about Terraform are provided. Please note that the information in this document is current as of December 17, 2021. The tools you are using, such as Terraform and Terraform Cloud, may have been updated, so</description></item><item><title>Terraformでのインフラ環境構築の手順書</title><link>https://moonorange.github.io/posts/public_cloud/terraform_provisioning/</link><pubDate>Fri, 17 Dec 2021 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/public_cloud/terraform_provisioning/</guid><description>インフラ構築の手順書 Terraformを使いWebサービスのデプロイ環境を構築していく際の手順を記述する。 Terraform CloudとGithub Acti</description></item><item><title>Golang Basic(Golang基礎)</title><link>https://moonorange.github.io/posts/programming_language/golang/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/programming_language/golang/</guid><description>概要 Golang についての基礎的な情報をまとめる資料である。 Go とは？ Google が開発したプログラミング言語であり、2009 年に最初のバージョンがオープンソース</description></item><item><title>Hash Set and Hash Table</title><link>https://moonorange.github.io/posts/dsa/hash/</link><pubDate>Mon, 15 Nov 2021 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/dsa/hash/</guid><description>The Principle of Built-in Hash Table The key value can be any hashable type. A value that belongs to a hashable type has a hash code, and this code is used to get the bucket index. Each bucket contains an array to store all the values in the same bucket initially If there are too many values in the bucket, these values will be stored in the form of height-balanced BST so that look-up can be more efficient.</description></item><item><title>Web脆弱性</title><link>https://moonorange.github.io/posts/security/web_security/</link><pubDate>Sun, 31 Oct 2021 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/security/web_security/</guid><description>CSRF(Cross Site Request Forgery) 外部サイトを経由したサーバーへの悪意のあるリクエストによって利用者の意図しない処理を実行する攻撃。 user がログインした状態で悪意あるリン</description></item><item><title>DB Random Notes(DB関連)</title><link>https://moonorange.github.io/posts/middleware/db/</link><pubDate>Sat, 23 Oct 2021 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/middleware/db/</guid><description>RAID 複数の Disk をまとめて一つの storage とする技術。 基本的にはデータを冗長化すること可用性を高めるためのものである。パフォーマンス向上のために用いられる</description></item><item><title>OOP Random Notes</title><link>https://moonorange.github.io/posts/software_design/oop/</link><pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/software_design/oop/</guid><description>Intro Random notes of relating OOP Terminology Parameter A parameter is a named variable passed into a function. Parameter variables are used to import arguments into functions. The difference between parameters and arguments Function parameters are the names listed in the function&amp;rsquo;s definition. Function arguments are the real values passed to the function. Parameters are initialized to the values of the arguments supplied. MDN Parameter Override Overriding a method means</description></item><item><title>Redis</title><link>https://moonorange.github.io/posts/middleware/redis/</link><pubDate>Tue, 21 Sep 2021 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/middleware/redis/</guid><description>Intro Redis は Remote Dictionary Server の略で高速でオープンソースなインメモリ key-value store である。 &amp;quot; データベース、キャッシュ、メッセージブローカー、キューとして利用される。 Usage example</description></item><item><title>OAuth2</title><link>https://moonorange.github.io/posts/security/oauth2/</link><pubDate>Sat, 04 Sep 2021 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/security/oauth2/</guid><description>はじめに OAuth2.0 とはサードパーティアプリケーションによる HTTP サービスへの限定的アクセスを可能にする認可フレームワークである。 The OAuth 2.0 authorization framework enables a third-party application to obtain limited</description></item><item><title>Linked List</title><link>https://moonorange.github.io/posts/dsa/linked_list/</link><pubDate>Fri, 14 May 2021 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/dsa/linked_list/</guid><description>Introduction The linked list is a linear data structure.
There are two types of linked lists, the singly linked list and the doubly linked list.
Singly Linked list The linked list elements are not stored at a contiguous location; the elements are linked using pointers.
Advantages over arrays
Dynamic size Ease of insertion/deletion (Need to move all elements after targeted element in array) Implementation
class Node(object): def __init__(self, val): self.</description></item><item><title>非同期処理(Asynchronous Programming)</title><link>https://moonorange.github.io/posts/frontend/asynchronous_programming/</link><pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/frontend/asynchronous_programming/</guid><description>概要 JavaScript を使う上で重要な概念である非同期処理について説明していく。 非同期処理とは 「ある関数が呼び出されたとき、戻り値として本来渡したい結果を返</description></item><item><title>ReactとReduxについて(About React and Redux)</title><link>https://moonorange.github.io/posts/frontend/react-redux/</link><pubDate>Fri, 26 Mar 2021 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/frontend/react-redux/</guid><description>概要 Summarizing what I learned about React and Redux React React, Javascript 周辺の用語 Babel 新しい仕様の JavaScript や JSX、TypeScript のコードを古いブラウザでも実行可能な JavaScript にコンパイルするコン</description></item><item><title>ネットワークについて(About network)</title><link>https://moonorange.github.io/posts/cs/network/</link><pubDate>Wed, 13 Jan 2021 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/cs/network/</guid><description>TCP/IP Transmission Control Protocol / Internet Protocol）は通信を実現する基盤技術 中でも「通信の信頼性を確保する」役割を担っているのが TCP IP とは Internet Protocol IP とは、複数の通信ネッ</description></item><item><title>プロセス間通信(Inter process communication)</title><link>https://moonorange.github.io/posts/cs/ipc/</link><pubDate>Wed, 13 Jan 2021 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/cs/ipc/</guid><description>マルチプロセスについて 複数のプロセスが、ある共有メモリ領域を競合するアクセスをしている時、競合アクセスしているプログラム部分をクリティカルセ</description></item><item><title>配列(Array)</title><link>https://moonorange.github.io/posts/dsa/array/</link><pubDate>Mon, 17 Aug 2020 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/dsa/array/</guid><description>実行時間 最悪実行時間(worst-case running time): 実行時間に対する保証の中で、最も強力なもの。 あるデータ構造の操作について最悪実行時間が f (n)</description></item><item><title>デザインパターン</title><link>https://moonorange.github.io/posts/software_design/design_patterns/</link><pubDate>Wed, 05 Aug 2020 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/software_design/design_patterns/</guid><description>デザインパターンとは 過去のソフトウェア設計者が発見し編み出した設計ノウハウを蓄積し、名前をつけ、再利用しやすいように特定の規約に従ってカタロ</description></item><item><title>デザインパターン２</title><link>https://moonorange.github.io/posts/software_design/design_patterns_2/</link><pubDate>Wed, 05 Aug 2020 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/software_design/design_patterns_2/</guid><description>8 Abstract Factory 抽象的な部品を組み合わせて抽象的な製品を作る 実装 抽象的な部品 Item link と tray のスーパークラス link と tray を同一視するためのクラス caption field はこの項目の見出</description></item><item><title>オペレーティングシステム(OS)</title><link>https://moonorange.github.io/posts/cs/os/</link><pubDate>Sun, 24 May 2020 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/cs/os/</guid><description>Operating System とコンピューターシステム プログラムとは 入力デバイス、ネットワークアダプタを介してコンピューターに何らかの処理を依頼する。 メモリ上に存在す</description></item><item><title>人間の目と畳み込みニューラルネットワーク(CNN)</title><link>https://moonorange.github.io/posts/ml/cnn/</link><pubDate>Fri, 24 Apr 2020 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/ml/cnn/</guid><description>CNN とは CNN（Convolutional Neural Networks: 畳み込みニューラルネットワーク）は､主に画像認識に利用されるネットワーク 構造的には､視神経系（視</description></item><item><title>awsでのインフラ構築について</title><link>https://moonorange.github.io/posts/public_cloud/infrastructure_setup_aws/</link><pubDate>Wed, 12 Feb 2020 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/public_cloud/infrastructure_setup_aws/</guid><description>chapter 1 サーバーというのは、「Linux」や「WindowsServer」など、サーバー用の OS をインストールしたコンピュータのこと VPC AmazonVirtualPrivateCloud の略。ユー</description></item><item><title>Binary Tree</title><link>https://moonorange.github.io/posts/dsa/binary_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/dsa/binary_tree/</guid><description>Overview A tree is a frequently-used data structure to simulate a hierarchical tree structure.
Each node of the tree will have a root value and a list of References to other nodes that are called child nodes. From graph view, a tree can also be defined as a directed acyclic graph that has N nodes and N-1 edges.
A Binary Tree is one of the most typical tree structures. As the name suggests, a binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child.</description></item></channel></rss>