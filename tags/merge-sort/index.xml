<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Merge Sort on Kei's Blog</title><link>https://moonorange.github.io/tags/merge-sort/</link><description>Recent content in Merge Sort on Kei's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 05 Oct 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://moonorange.github.io/tags/merge-sort/index.xml" rel="self" type="application/rss+xml"/><item><title>Implementation of Merge Sort in Python</title><link>https://moonorange.github.io/posts/dsa/sort/merge_sort/</link><pubDate>Thu, 05 Oct 2023 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/dsa/sort/merge_sort/</guid><description>Merge Sort In sorting n objects, merge sort has an average and worst-case performance of O(n log n).
Merge sort is a stable sort in the most implementations. The most common implementation does not sort in place, meaning it requires extra space.
Implementation in Python from typing import List # Python merge sort implementation # Time complexity: O(NlogN), space complexity: O(N) def merge_sort(nums: List[int]): # Base case if len(nums) &amp;lt;= 1: return nums mid = len(nums) // 2 left, right = merge_sort(nums[:mid]), merge_sort(nums[mid:]) return merge(left, right) def merge(left: List[int], right: List[int]): i, j = 0, 0 res = [] # Compare the elements in the left and right list and append the smaller one to the result list while i &amp;lt; len(left) and j &amp;lt; len(right): if left[i] &amp;lt;= right[j]: res.</description></item></channel></rss>