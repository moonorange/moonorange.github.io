<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on Kei's Blog</title><link>https://moonorange.github.io/tags/go/</link><description>Recent content in Go on Kei's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 21 Apr 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://moonorange.github.io/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Learn gRPC, GraphQL and Kubernetes by building Microservices: Part 3 - Kubernetes</title><link>https://moonorange.github.io/posts/projects_to_learn/go_microservices/part3/</link><pubDate>Sun, 21 Apr 2024 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/projects_to_learn/go_microservices/part3/</guid><description>Intro This is the third and last post in a series about learning gRPC, GraphQL and Kubernetes by building Microservices in Go.
Here is a list of posts in the series:
Part 1 - gRPC Microservices Part 2 - GraphQL BFF Part 3 - Orchestrating by Kubernetes
Full code is in here
Orchestrate services by Kubernetes Understanding Kubernetes Kubernetes is an open-source container orchestration platform. Its purpose is to automate deployment, scaling, and management of containerized applications.</description></item><item><title>Learn gRPC, GraphQL and Kubernetes by building Microservices in Go: Part 2 - GraphQL BFF</title><link>https://moonorange.github.io/posts/projects_to_learn/go_microservices/part2/</link><pubDate>Sat, 20 Apr 2024 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/projects_to_learn/go_microservices/part2/</guid><description>Intro This is the second post in a series about learning gRPC, GraphQL and Kubernetes by building Microservices in Go. Here is a list of posts in the series:
Part 1 - gRPC Microservices Part 2 - GraphQL BFF Part 3 - Orchestrating by Kubernetes Full code is in here
BFF Backend For Frontend (BFF) is an architectural pattern where a dedicated backend service is created for each frontend application or client type.</description></item><item><title>Learn gRPC, GraphQL and Kubernetes by building Microservices: Part 1 - gRPC MicroServices</title><link>https://moonorange.github.io/posts/projects_to_learn/go_microservices/part1/</link><pubDate>Fri, 19 Apr 2024 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/projects_to_learn/go_microservices/part1/</guid><description>Intro This is the first post in a series about learning gRPC, GraphQL and Kubernetes by building Microservices in Go.
In this series of posts, we will embark on a journey to implement a Backend For Frontend (BFF) and microservices architecture utilizing gRPC and GraphQL.
This project serves as an educational endeavor to understand the intricacies of microservices communication and the benefits of using gRPC and GraphQL.
Here is a list of posts in the series:</description></item><item><title>Implementation of Job Queue model using goroutine and channel</title><link>https://moonorange.github.io/posts/programming_language/job_queues_go/</link><pubDate>Thu, 11 Apr 2024 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/programming_language/job_queues_go/</guid><description>Introduction In concurrent programming, managing tasks efficiently is crucial. One common pattern is the job queue model, where multiple tasks (jobs) are submitted to a queue and processed asynchronously by worker routines. In this blog post, we&amp;rsquo;ll explore how to implement a job queue model in Go using goroutines and channels.
Understanding the Job Queue Model At its core, the job queue model consists of two main components:
Job Queue: The job queue is a data structure that holds tasks awaiting execution.</description></item><item><title>Go Concurrency Model</title><link>https://moonorange.github.io/posts/programming_language/go_concurrency_model/</link><pubDate>Sun, 07 Apr 2024 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/programming_language/go_concurrency_model/</guid><description>Intro This article aims to summarize the key concepts and principles of Go&amp;rsquo;s concurrency model that I&amp;rsquo;ve learned.
To test your understanding and reinforce your knowledge, a quiz is available at the end of the article.
Goroutines A goroutine is a lightweight independently executing function with its own call stack.
While not equivalent to a thread, conceptually, it can be thought of as a very cheap thread.
Here&amp;rsquo;s how you can use goroutines:</description></item><item><title>Write a Large Amount of Data to CSV File with Go (Golang)</title><link>https://moonorange.github.io/posts/programming_language/golang_goroutines/</link><pubDate>Sat, 09 Sep 2023 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/programming_language/golang_goroutines/</guid><description>Introduction Have you ever found yourself in a situation where you needed to prepare a substantial amount of data for testing your code? If so, you&amp;rsquo;re not alone. Working with large datasets is a common requirement in software development, and Go provides some powerful tools to help you accomplish this efficiently.
In this blog post, I&amp;rsquo;ll share my approach to writing a large amount of data into a CSV file using Go, and I&amp;rsquo;ll demonstrate how to leverage Goroutines to make the process more efficient and faster.</description></item><item><title>Stack and Queue</title><link>https://moonorange.github.io/posts/dsa/queue_stacks/</link><pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/dsa/queue_stacks/</guid><description>Queue FIFO
package queue import &amp;#34;sync&amp;#34; type node struct { data interface{} next *node } type Queue struct { head *node tail *node count int lock *sync.Mutex } func NewQueue() *Queue { return &amp;amp;Queue{lock: &amp;amp;sync.Mutex{}} } func (q *Queue) Len() int { q.lock.Lock() defer q.lock.Unlock() return q.count } func (q *Queue) Push(data interface{}) { q.lock.Lock() defer q.lock.Unlock() ele := &amp;amp;node{data: data} if q.head == nil { q.head = ele q.tail = ele } else { q.</description></item><item><title>Golang Basic(Golang基礎)</title><link>https://moonorange.github.io/posts/programming_language/golang/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://moonorange.github.io/posts/programming_language/golang/</guid><description>概要 Golang についての基礎的な情報をまとめる資料である。 Go とは？ Google が開発したプログラミング言語であり、2009 年に最初のバージョンがオープンソース</description></item></channel></rss>